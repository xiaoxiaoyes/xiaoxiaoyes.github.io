---
layout: post
title: "软件的复杂度"
description: "《Unix 编程艺术》 读书心得 (三)"
tags: [Unix, Linux, Design, 读书笔记]
image:
    feature: taoup.png
---

`UNIX`世界注重考虑软件的简单性、复杂度和软件最佳规模。

> `UNIX`程序员追求简单的激情，源自注重实效的事实：复杂度就是成本。复杂的软件更难于开发，难于测试，难于调试，难于维护————更重要的，难于学习和使用。

> 软件的复杂度有三个来源，接口复杂度，实现复杂度，代码量

复杂度的三个来源，也可以认为是复杂度的三个维度。这三个维度还会互相影响，例如如果希望接口复杂度小，则实现复杂度和代码量可能需要提高；如果希望实现复杂度低，则可能带来更高的接口复杂度（暴露的接口更加底层，更难使用）。第三个维度代码量也会受到前两个维度复杂度的影响，也会影响前两个维度。在书中，作者举出了一个例子，有时候为了保证代码库规模在约束范围内，需要使用复杂晦涩的技法或者底层汇编语言，提高了实现复杂度。但是，在硬件能力飞速发展的今天，大部分情况下，我们已经不需要专门考虑代码库水平的问题，只可能出现在某些极端的嵌入式环境下。大部分情况下，可以接受代码量被动的受到接口复杂度和实现复杂度的影响，而不需要主动约束代码量的复杂度。

<!-- brief-remark -->

关于复杂度的三个维度，软件开发过程中需要做的是**权衡**；特别是如何在接口复杂度和实现复杂度中折中，避免陷入接口过于复杂或者实现过于复杂的陷阱。一个历史上的权衡折中例子是：

> 早期的分布式超文本工程，严重局限于*MIT哲学（倾向接口简单）*的限定；无被指物的链接在用户界面上是一个不可接受的障碍；这就限制了系统只能在一个受控的闭集文档中浏览，或者必须实现各种日益复杂的复制、缓存、索引方法来防止文档的随机丢失。Tim Berners-Lee转用经典的*New Jersey(倾向实现简单)*哲学解决了这个疑难杂症。他所采用的简单实现就是允许*404:Not Found*作为一个响应，这使得万维网非常轻便，并获得了广泛的传播和巨大的成功。

《没有银弹》一文中，作者提到软件开发的复杂度分为偶然复杂度和本质复杂度。在《UNIX编程艺术》中，作者也针对软件复杂度的类型进行了一些讨论。与《没有银弹》中的讨论不同的是，他讲软件开发复杂度分为本质的、偶然的和选择的三种，并给出了下面这个表格：

<figure>
    <img src="/images/taoup_note2_0.JPG"/>
</figure>

图中的偶然复杂度（第一行），都是由于不合适的工程实践、差的软件设计引起的，也是最容易通过提升开发人员的开发能力解决的复杂度。

图中的选择复杂度（第二行），与开发选择的工具、可选的功能和项目开发的约定决定的。对于代码库规模、实现复杂度对应的选择复杂度，通过选择更合适的开发语言、更强大的开发测试调试工具、更强大的开发实用套件（如基础工具模块等）、更方便的开发约定（如命名约定、代码组织约定）来降低；这方面更依赖项目开发**初期**的统一计划和管理。而对于接口复杂度对应的选择复杂度，需要有效的甄别项目的可选功能和核心功能；通过忽略可选功能来降低接口复杂度（也可以降低实现复杂度）。

图中的本质复杂度（第三行），在《没有银弹》和本书中均指代相同的东西，即由软件要处理问题决定的，必然存在无法消除的复杂度；由于本质复杂度的存在，软件开发才是一项智力密集的挑战性工作，关于如何降低本质复杂度，书中提到：

> 而要去除本质复杂度，就只能通过对现实真谛的洞察和顿悟，从根本上重新定义所要解决的问题。
