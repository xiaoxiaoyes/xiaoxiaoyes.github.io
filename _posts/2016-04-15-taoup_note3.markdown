---
layout: post
title: "软件优化"
description: "《Unix 编程艺术》 读书心得 (四)"
tags: [Unix, Optmization, 读书笔记]
image:
    feature: taoup.png
---

在书中，作者只用了一章的篇幅对于软件优化的主题进行了介绍，可以看出`UNIX`世界对于优化的讨论并不丰富（相对）。这也说明了`UNIX`哲学下对待优化的态度：

> Unix经验告诉我们最主要的就是如何知道何时不去优化。其次，最有效的优化往往就是优化之外的其他事情，如：清晰干净的设计

> 程序员工具箱中最强大的优化技术就是不做优化

*Premature optimization is the root of all evil.*是一句广为流传的黑客谚语，中文往往翻译为*过早优化是万恶之源*。在软件开发过程中，效率优化的目标往往与干净清爽的设计、代码可扩展性、代码可读性的目标是相冲突的。为了优化效率，开发者往往可能采用一些奇淫技巧，难于理解的数据结构和算法，甚至打破原先模块之间的接口，在本无偶合的地方加入强耦合，降低模块的可复用。效率和软件其他优秀品质的目标（可以统称设计方面）的这种矛盾，告诫我们不要在软件设计与开发的初期就着手进行优化操作，这是需要关注的是设计问题，而不是效率问题，设计问题远远更为重要。

<!-- brief-remark -->

在初期需要更关注设计的另外一个理由就是，除非有着非常丰富的经验，开发者是很难确定代码中的那个部分会出现会出现效率问题；软件作为一个与系统接口的交互体有其天然复杂性。这种复杂性不光光由本身代码产生，也与软件所属的平台（操作系统）有关，也与软件的编译环境有关（如编译器的是否有某些优化），甚至与软件运行所在硬件有关系（是否具有某种硬件加速的方式）。总之，这种复杂性不太可能由开发者在设计时或者开发初期分析清楚，因此，这时候所做的优化往往就不是“对症下药”的。

抨击过早优化的另外一个理由是，不要过早优化可以产生更清晰的设计，更清晰的设计反过来可以方便优化过程。清晰的设计可以把效率瓶颈限制在较小的范围内，这样开发者可以集中精力优化很小的代码范围，只要保证这个范围的接口不变，就不会担心产生意外的影响。

书中关于优化的有一个有趣的点：

> 摩尔定律的指数效应————最聪明、最便宜、常常也是最迅速的性能提升方法，就是等上几个月，期望硬件性能更好。考虑到硬件和程序员时间成本比率，总是有更值得打发时间的事，别去优化一个工作中的系统。

为什么要优化，允许我说一句不负责任的话：**因为硬件不是完美的**；运算时需要时间的、内存不是无限的、网络不是无延迟的。但是，得益于我们聪明的硬件设计师们，硬件性能在飞速发展中。相同的软件，在前一代硬件有性能问题，在下一代硬件可能完全没问题。所以，在进行优化之前，需要考虑软件所面向的硬件平台是什么样的，不同平台的硬件资源不同，会深刻影响到是否优化、做何种优化的决策。例如，对于服务器软件，也许只要升级硬件就可以解决，也很便宜；对于客户端甚至是移动端开发，硬件更新不方面，那就需要软件进行优化了。


关于如何进行优化，书中简短的提到几点：

> 先估量，后优化

> 估量有误差，综合多次profiler结果

> 不妨悲观地认为，许多优化方法都是暂时的而且常常随着成本比例而变化。唯一可去了解的方法就是估量后再看。

这个几乎是所有关于优化的讨论必不可少的部分。

> 永远不要讲核心数据结构和时间关键循环抛出缓存

这里的缓存作者主要指CPU级别的缓存。在现代开发语言中，开发者不会直接控制CPU缓存的管理，此项工作往往由编译器完成。因此，除非别无它发，不要试图应用此条，原因很明显，将会损失可移植性并引入BUG。
